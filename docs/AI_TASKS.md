# ЗАДАНИЕ 1

## Цель
Разработай код модуля логгера на языке Go для приложения, которое работает на системах с entware/openwrt (устройства embedded Linux) и имеет ограниченное количество ОЗУ и места на диске.

## Область ответственности
Логгер должен:

1. Писать только в указанный файл.
2. Логгер должен работать с помощью unix-сокетов. Клиентская и серверная горутина должны быть разделены в различных файлах.
3. Файл лога должен создаваться, если отсутствует, сразу при создании экземпляра логгера.
4. Ротироваться с заданными параметрами из файла конфигурации без использования сторонних библиотек.
5. Он не должен быть глобальным, исключительно инкасулирование
6. Журналировать состояния различных сервисов DNS/API/HTTP и наблюдетелем за изменениями в файлах и директориях
7. Задавать формат даты и времени через конфигурацию
8. Писать в формате TXT в формате: [СЛУЖБА] ДАТА ВРЕМЯ [УРОВЕНЬ] "СООБЩЕНИЕ"
9. Иметь и уметь фиксировать различные уровни Debug/Info/Warn/Error/Fatal/Panic с помощью функций Debug/Info/Warn/Error/Fatal/Panic и при помощи функций с форматированием Debugf/Infof/Warnf/Errorf/Fatalf/Panicf
10. Иметь функции вывода Debug/Info/Warn/Error/Fatal/Panic с основной службой типа MAIN:  [MAIN] ДАТА ВРЕМЯ [УРОВЕНЬ] "СООБЩЕНИЕ", т.е. сама функция должна быть вида log.Debug("Сообщение")
11. Иметь функции вывода Debug/Info/Warn/Error/Fatal/Panic в заданных типах служб (DNS, HTTP, API, CONF, VPN) и вывод в формате:  [СЛУЖБА] ДАТА ВРЕМЯ [УРОВЕНЬ] "СООБЩЕНИЕ", т.е. использование функции Info для вывода сообщения, функция должна быть вида:
    - logger := logger.New(config, []string{"DNS", "HTTP", "API", "CONF", "VPN"})
    - dnslog := logger.SetService("DNS")
    - dnslog.Info("Сообщение")
12. Должен иметь функцию установки уровня логирования SetLevel
13. Должен иметь функцию получения пути до LogFile
14. Должен иметь функцию обновления настройки логирования без полной переинициализации UpdateConfig
15. Должен иметь функцию получения настройки логирования по умолчанию GetDefaultLoggingConfig
16. Должен иметь функцию LogPanic обработчик паники с логированием
17. Должен иметь функцию получения записей из файла логов GetLogEntries с заданной фильтрацией: 
    1.  по дате и времени
    2.  по уровню логирования
    3.  по компоненту
    4.  по компоненту и уровню логирования
    5.  по компоненту и дате и времени
    6.  по компоненту и уровню логирования и дате и времени
18. При этом логгер сделай так, чтобы можно было стандартные службы логгера добавлять в самом начале в виде массива в виде []string{"DNS", "HTTP", "API", "CONF", "VPN"} и затем в лагере все стандартные службы создавались бы автоматически? 
19. - Дублирование сообщений в системный лог
20. Не используй сторонние библиотеки
21. Код должен быть приспособлен для малых маршрутизаторов и работать на системах с entware/openwrt. 
22. Управление конфигурацией логгера разработывать не нужно, так как модуль уже написан. Однако для описания конфигурации логгера используй структуру Config с форматом yaml.
23. Тесты и прочее окружение для разработки писать не нужно.
24. Не используем какой либо вывод текстовой инофрмации в терминал при помощи fmt.Print*() функций для отладки.
25. Сделай вывод в формате ниже:
[MAIN ] 2024-01-15 14:30:22 [INFO ] "Application started"
[DNS  ] 2024-01-15 14:30:23 [DEBUG] "Resolving domain example.com"
[HTTP ] 2024-01-15 14:30:24 [ERROR] "Failed to handle request"

Вместо:
[MAIN] 2024-01-15 14:30:22 [INFO] "Application started"
[DNS] 2024-01-15 14:30:23 [DEBUG] "Resolving domain example.com"
[HTTP] 2024-01-15 14:30:24 [ERROR] "Failed to handle request"

Другими словами, чтобы к именам сервисов и уровней добавлялись бы пробелы до максимальной длины имени сервиса или уровня.

# ЗАДАНИЕ 2

`После разработки кода модуля:`

1. Сделай его рефакторинг и оптимизацию, с учетом производительности и безопасности для системы entware/openwrt:
   - при необходимости добавь кеширование данных для ускорения работы
   - опиши, что ты сделал и как это повлияло на производительность и безопасность
2. Добавь подробные комментарии в код и переведи все сообщения в коде на русский язык 
3. Напиши подробную документацию о том, как можно использовать модуль на русском языке с примерами


# ЗАДАНИЕ 3
1. Напиши тесты для модуля с максимальным покрытием
2. Используй mock для тестирования в случае необходимости.






## Техническое задание: Модуль конфигурации на базе архитектуры logger

### Обзор

Разработать модуль конфигурации `internal/config` с архитектурой, аналогичной модулю logger, оптимизированный для embedded устройств с ограниченными ресурсами.

### Анализ исходного модуля logger

**Ключевые архитектурные решения модуля logger:**
- Клиент-серверная архитектура через Unix сокеты
- Разделение на основной интерфейс (Logger), клиент (LogClient) и специализированные компоненты (ServiceLogger)
- Memory pooling через sync.Pool для оптимизации памяти
- Потокобезопасность через sync.Mutex/RWMutex
- Кеширование объектов для повторного использования
- Валидация и фильтрация данных
- Переподключение с exponential backoff
- Оптимизация для embedded систем (константы, лимиты)
- Graceful shutdown и comprehensive error handling

### Цель

Создать модуль конфигурации с аналогичной архитектурой для централизованного управления конфигурацией всех сервисов системы.

### Функциональные требования

#### 1. Основные компоненты (аналогично logger)

**1.1 ConfigManager (config.go)**
- Основная обертка для клиентских приложений
- Методы: Load(), Save(), Get(), Set(), Reload(), Validate()
- Поддержка hot-reload конфигурации
- Интеграция с переменными окружения

**1.2 ConfigClient (client.go)**
- Клиентская часть для подключения к серверу конфигурации
- Соединение через Unix сокеты
- JSON протокол для IPC
- Автоматическое переподключение с exponential backoff
- Кеширование конфигурации на клиенте

**1.3 ServiceConfig (service.go)**
- Конфигурация для конкретного сервиса
- Изоляция настроек по сервисам
- Валидация специфичных для сервиса параметров

#### 2. Структуры данных (message.go)

**2.1 ConfigMessage**
```go
type ConfigMessage struct {
    Service   string                 `json:"service"`
    Section   string                 `json:"section"`
    Key       string                 `json:"key,omitempty"`
    Value     interface{}            `json:"value,omitempty"`
    Values    map[string]interface{} `json:"values,omitempty"`
    Timestamp time.Time              `json:"timestamp"`
    ClientID  string                 `json:"client_id,omitempty"`
}
```

**2.2 ConfigEntry**
```go
type ConfigEntry struct {
    Service   string      `json:"service"`
    Section   string      `json:"section"`
    Key       string      `json:"key"`
    Value     interface{} `json:"value"`
    Type      ValueType   `json:"type"`
    Timestamp time.Time   `json:"timestamp"`
    Source    string      `json:"source"` // file, env, default
}
```

**2.3 FilterOptions**
```go
type FilterOptions struct {
    Service   string     `json:"service,omitempty"`
    Section   string     `json:"section,omitempty"`
    Key       string     `json:"key,omitempty"`
    Source    string     `json:"source,omitempty"`
    Modified  *time.Time `json:"modified,omitempty"`
    Limit     int        `json:"limit,omitempty"`
}
```

#### 3. Типы значений (types.go)

**3.1 ValueType**
```go
type ValueType int

const (
    STRING ValueType = iota
    INT
    BOOL
    FLOAT
    DURATION
    SLICE
    MAP
)
```

**3.2 Валидация и парсинг**
- Автоматическое определение типов
- Валидация значений по схеме
- Конвертация типов с проверкой

#### 4. Конфигурация по умолчанию (defaults.go)

**4.1 Embedded-оптимизированные константы**
```go
const (
    DEFAULT_CONFIG_FILE        = "/etc/kvaspro/config.yaml"
    DEFAULT_SOCKET_PATH        = "/var/run/kvaspro/config.sock"
    DEFAULT_CONNECTION_TIMEOUT = 30
    DEFAULT_CACHE_SIZE         = 1000
    DEFAULT_CACHE_TTL          = 10 * 60 // 10 минут
    DEFAULT_MAX_MEMORY         = 20 * 1024 * 1024 // 20MB
    DEFAULT_BACKUP_COUNT       = 3
)
```

**4.2 Конфигурация по умолчанию**
- Настройки для DNS, HTTP, API, VPN, WDOG сервисов
- Оптимальные значения для embedded устройств
- Минимальное потребление ресурсов
- Дублирование сообщений в системный лог

### Технические требования

#### 1. Архитектура

**1.1 Клиент-серверная модель**
- Сервер конфигурации как отдельный процесс
- Клиенты подключаются через Unix сокеты
- JSON протокол для межпроцессного взаимодействия

**1.2 Потокобезопасность**
- sync.RWMutex для чтения/записи конфигурации
- sync.Mutex для операций с соединениями
- Атомарные операции где возможно

**1.3 Memory pooling**
```go
var (
    configMessagePool = sync.Pool{
        New: func() interface{} {
            return &ConfigMessage{}
        },
    }
    
    configEntryPool = sync.Pool{
        New: func() interface{} {
            return &ConfigEntry{}
        },
    }
)
```

#### 2. Производительность

**2.1 Кеширование**
- Кеш конфигурации на клиенте
- TTL для записей кеша
- Инвалидация при изменениях

**2.2 Оптимизация памяти**
- Переиспользование объектов через sync.Pool
- Предварительное выделение слайсов и map
- Минимизация аллокаций в горячих путях

**2.3 Лимиты ресурсов**
- Максимальный размер конфигурации: 20MB
- Максимальное количество подключений: 50
- Таймауты для всех операций

#### 3. Надежность

**3.1 Переподключение**
- Exponential backoff при потере соединения
- Максимальное количество попыток: 5
- Fallback на локальный кеш при недоступности сервера

**3.2 Валидация**
- Схема валидации для каждого сервиса
- Проверка типов и диапазонов значений
- Откат к предыдущей конфигурации при ошибке

**3.3 Backup и восстановление**
- Автоматическое создание backup файлов
- Ротация backup файлов (максимум 3)
- Восстановление из backup при повреждении основного файла

#### 4. Протокол взаимодействия

**4.1 Типы сообщений**
```go
const (
    MsgTypeGet         = "get"          // Получить значение
    MsgTypeSet         = "set"          // Установить значение
    MsgTypeGetSection  = "get_section"  // Получить секцию
    MsgTypeSetSection  = "set_section"  // Установить секцию
    MsgTypeReload      = "reload"       // Перезагрузить конфигурацию
    MsgTypeValidate    = "validate"     // Валидировать конфигурацию
    MsgTypeWatch       = "watch"        // Подписка на изменения
    MsgTypeUnwatch     = "unwatch"      // Отписка от изменений
    MsgTypeResponse    = "response"     // Ответ сервера
    MsgTypeError       = "error"        // Ошибка
    MsgTypePing        = "ping"         // Проверка соединения
    MsgTypePong        = "pong"         // Ответ на ping
)
```

### Файловая структура

```
internal/config/
├── config.go          # Основной интерфейс ConfigManager
├── client.go          # ConfigClient для сетевого взаимодействия
├── service.go         # ServiceConfig для сервисов
├── message.go         # Структуры сообщений и pooling
├── types.go           # ValueType и валидация
├── defaults.go        # Конфигурация по умолчанию
├── schema.go          # Схемы валидации для сервисов
├── cache.go           # Кеширование конфигурации
├── watcher.go         # Отслеживание изменений файлов
├── backup.go          # Backup и восстановление
└── server.go          # Сервер конфигурации (отдельный процесс)
```

### Интеграция с существующей системой

#### 1. Зависимости
- `internal/env` для переменных окружения
- `github.com/spf13/viper` для парсинга YAML (как в старом модуле)
- Минимальные внешние зависимости

#### 2. Совместимость
- Поддержка существующих конфигурационных файлов
- Миграция со старого модуля конфигурации
- Обратная совместимость API

#### 3. Интеграция с сервисами
```go
// Пример использования в DNS сервисе
configManager, err := config.New(&config.Config{
    Service: "DNS",
    SocketPath: "/var/run/kvaspro/config.sock",
}, []string{"DNS", "CACHE", "SECURITY"})

dnsConfig := configManager.SetService("DNS")
port := dnsConfig.GetInt("server.port", 53)
timeout := dnsConfig.GetDuration("server.timeout", 5*time.Second)
```

### Тестирование

#### 1. Unit тесты
- Тестирование каждого компонента отдельно
- Моки для сетевого взаимодействия
- Тестирование валидации и конвертации типов

#### 2. Integration тесты
- Тестирование клиент-серверного взаимодействия
- Тестирование переподключения и fallback
- Тестирование hot-reload и watch функциональности

#### 3. Performance тесты
- Бенчмарки операций get/set
- Тестирование memory pooling
- Профилирование на целевом оборудовании

### Этапы разработки

#### Этап 1: Базовая структура
- [ ] Создание основных структур данных
- [ ] Реализация ConfigManager и ConfigClient
- [ ] Базовый протокол взаимодействия

#### Этап 2: Функциональность
- [ ] Валидация и типизация
- [ ] Кеширование и memory pooling
- [ ] Конфигурация по умолчанию

#### Этап 3: Надежность
- [ ] Переподключение и error handling
- [ ] Backup и восстановление
- [ ] Watch функциональность

#### Этап 4: Оптимизация
- [ ] Performance тестирование
- [ ] Оптимизация для embedded устройств
- [ ] Интеграция с существующими сервисами

### Критерии готовности

- [ ] Все unit и integration тесты проходят
- [ ] Memory usage не превышает 20MB
- [ ] Время отклика get/set операций < 1ms
- [ ] Успешная интеграция с DNS, HTTP, API сервисами
- [ ] Документация и примеры использования
- [ ] Performance профилирование на целевом оборудовании
